<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>README</title>


<style type="text/css">
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #fff;
    background-color: #282a36;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;
}
a {
    color: #59acf3;
}
a:hover {
    color: #a7d8ff;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #fff;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
	color: #ff4a14;
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #bf370f;
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #282a36;
    color: #ff4a14;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>

<style type="text/css">
/**
 * prism.js Dark theme for JavaScript, CSS and HTML
 * Based on the slides of the talk “/Reg(exp){2}lained/”
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: white;
	background: none;
	text-shadow: 0 -.1em .2em black;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

pre[class*="language-"],
:not(pre) > code[class*="language-"] {
	background: hsl(30, 20%, 25%);
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	border: .3em solid hsl(30, 20%, 40%);
	border-radius: .5em;
	box-shadow: 1px 1px .5em black inset;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .15em .2em .05em;
	border-radius: .3em;
	border: .13em solid hsl(30, 20%, 40%);
	box-shadow: 1px 1px .3em -.1em black inset;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: hsl(30, 20%, 50%);
}

.token.punctuation {
	opacity: .7;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol {
	color: hsl(350, 40%, 70%);
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: hsl(75, 70%, 60%);
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
	color: hsl(40, 90%, 60%);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: hsl(350, 40%, 70%);
}

.token.regex,
.token.important {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

.token.deleted {
	color: red;
}
</style>

<style type="text/css">
pre.line-numbers {
	position: relative;
	padding-left: 3.8em;
	counter-reset: linenumber;
}

pre.line-numbers > code {
	position: relative;
}

.line-numbers .line-numbers-rows {
	position: absolute;
	pointer-events: none;
	top: 0;
	font-size: 100%;
	left: -3.8em;
	width: 3em; /* works for line-numbers below 1000 lines */
	letter-spacing: -1px;
	border-right: 1px solid #999;

	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;

}

	.line-numbers-rows > span {
		pointer-events: none;
		display: block;
		counter-increment: linenumber;
	}

		.line-numbers-rows > span:before {
			content: counter(linenumber);
			color: #999;
			display: block;
			padding-right: 0.8em;
			text-align: right;
		}
</style>


</head>

<body>

<h1 id="toc_0">PHPUnit at Selesti with Laravel</h1>

<h2 id="toc_1">Index</h2>

<ul>
<li>Setting up PHPUnit

<ul>
<li>Environment Configs</li>
</ul></li>
<li>Preparing your tests

<ul>
<li>Migrations</li>
<li>Using <code>setUp()</code> and <code>tearDown()</code> </li>
<li>Authenticating Users</li>
</ul></li>
<li>Testing Concepts

<ul>
<li>Feature Tests</li>
<li>Browser Tests</li>
<li>Unit Tests</li>
<li>TDD</li>
</ul></li>
<li>Writing Tests

<ul>
<li>Arrange</li>
<li>Act</li>
<li>Assert</li>
<li><del>Mocks</del></li>
<li><del>API Integration</del></li>
</ul></li>
<li><del>Running Tests</del>

<ul>
<li><del>Refactoring</del></li>
</ul></li>
</ul>

<h2 id="toc_2">Setting up PHPUnit</h2>

<p>Laravel luckily comes with some boilerplate code to get things going for us, this includes:</p>

<ul>
<li>Bootstrapping your application</li>
<li>A base <code>TestCase.php</code> to extend from</li>
<li>Custom testing helpers for JSON/Auth etc</li>
</ul>

<p>The <code>CreatesApplication</code> trait spins up a minimal copy of Laravel and allows you a PHP entry point to make global changes to your application state. One example could be simplifying the hashing method to speed up your tests.</p>

<div><pre class="line-numbers"><code class="language-php">public function createApplication()
{
    $app = require __DIR__.&#39;/../bootstrap/app.php&#39;;
    $app-&gt;make(Kernel::class)-&gt;bootstrap();
    
    // This makes the hashing less random, but speeds up all the
    // methods by keeping it more simple. It&#39;s test data after
    // all and will get wiped immediately!
    Hash::setRounds(4);

    return $app;
}</code></pre></div>

<p>We also have access to a prebuilt <code>phpunit.xml</code> file which PHPUnit will automatically read when running.</p>

<p>Most of this can remain the same however it is usefull to note a few key areas.</p>

<p>One area you may wish to change is <code>stopOnFailure=&quot;false&quot;</code> as if you have 100 tests and test 2 stops, it will continue to run the rest and take up time. You may want to set this to <code>true</code> to kill the process and let you fix - unless of course you want to see the full result!</p>

<p>By default Laravel gives you 2 types of tests <code>Feature</code> and <code>Unit</code> you can rename these, or create other folders and continue adding them to the <code>&lt;testsuites&gt;</code> property e.g </p>

<div><pre class="line-numbers"><code class="language-markup">&lt;testsuite name=&quot;Selenium&quot;&gt;
    &lt;directory suffix=&quot;Test.php&quot;&gt;./tests/Selenium&lt;/directory&gt;
&lt;/testsuite&gt;</code></pre></div>

<p>Now you can house all your Selenium specific tests in <code>./tests/Selenium</code></p>

<h3 id="toc_3">Environment Configs</h3>

<p>Arguably the most important part of the config is the <code>&lt;php&gt;</code> section which allows us to set environment variables.</p>

<p>This array of variables effectively overwrites anything in your <code>.env</code> file, 9 times out of 10 you&#39;ll need to add the following 2 lines</p>

<div><pre class="line-numbers"><code class="language-markup">&lt;env name=&quot;DB_CONNECTION&quot; value=&quot;sqlite&quot;/&gt;
&lt;env name=&quot;DB_DATABASE&quot; value=&quot;:memory:&quot;/&gt;</code></pre></div>

<p>What this will do is set the Laravel Database Driver to <code>sqlite</code> rather than hitting a real database and either nuking its data or slowing it down.</p>

<p>You then can set the database to a magic method called <code>:memory:</code> - What this will do is spin up a sqlite database in memory whilst the tests are running rather than writing to a real file - this again speeds up the testing process and keeps your real data intact.</p>

<blockquote>
<p>Remember; you are testing your <strong>applications code</strong>, so we don&#39;t need to worry about using a real database - thats Oracles job now!</p>
</blockquote>

<h2 id="toc_4">Preparing Your Tests</h2>

<p>Laravel will give you 2 example tests to... delete, they are purely there for informative reasons! They are empty and located in <code>tests/Feature/ExampleTest.php</code> and <code>tests/Unit/ExampleTest.php</code></p>

<p>You can create your own ones using the CLI - you have 2 options here, either to generate a Feature test or a Unit test (will explain differences later)</p>

<p>To create a unit test we can use <code>php artisan make:test UserServiceTest --unit</code></p>

<p>To create a feature test we can use <code>php artisan make:test UserApiTest</code></p>

<p>Simple!</p>

<p>This will create you a class looking something like</p>

<div><pre class="line-numbers"><code class="language-php">&lt;?php

namespace Tests\Unit;

use Tests\TestCase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Foundation\Testing\RefreshDatabase;

class UserServiceTest extends TestCase
{
    /**
     * A basic test example.
     *
     * @return void
     */
    public function testExample()
    {
        $this-&gt;assertTrue(true);
    }
}
</code></pre></div>

<p>You&#39;ll most likely not need this, but you can edit if you want - the 2 things you want to look at are the 2 traits it imports allowing you to use if you want e.g </p>

<div><pre class="line-numbers"><code class="language-php">use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Foundation\Testing\RefreshDatabase;</code></pre></div>

<h3 id="toc_5">WithFaker</h3>

<p>This imports a copy of faker into your tests so you can generate fake data e.g</p>

<div><pre class="line-numbers"><code class="language-php">$fakeCompanyName = $this-&gt;faker()-&gt;companyName();</code></pre></div>

<h3 id="toc_6">RefreshDatabase</h3>

<p>As each test is designed to run in isolation, so you do not want leaked data from 1 test into another, e.g</p>

<div><pre class="line-numbers"><code class="language-php">function testOne()
{
    User::create():
    
    User::count(); // 1
}

function testTwo()
{
    User::create():
    
    User::count(); // 2
}</code></pre></div>

<p>As you can see here you would be getting side effects if you needed to test a count or fetch data etc - to avoid things like this Laravel provides a fresh copy of your application for each test method.</p>

<p>If your tests do not require any database connectivity you can just ignore this trait, e.g if you&#39;re testing some mathmatic functions like <code>MathsService::addTogether(1, 2); // 3</code> you&#39;re fine!</p>

<p>However if you need database interations e.g you need to test relationships etc, then you need to import the <code>RefreshDatabase</code> trait - this will between each test effectively nuke your database and reconstruct it from your migration files (in what ever way it believes most performant) - it wil also run the default <code>DatabaseSeeder</code> to set up any default things you need.</p>

<blockquote>
<p>Remember; Only <code>use RefreshDatabase;</code> when needed as it adds performance overhead and slowly eats into the run time of tests. And if a test suite takes too long to run, people are less likely to continuously run it.</p>
</blockquote>

<h3 id="toc_7"> Using <code>setUp()</code> and <code>tearDown()</code></h3>

<p>Sometimes you need to run repetative tasks before your tests, e.g imagine you&#39;re testing an API and you need to set up a user account, rather than doing it for every test, you can consolidate it into something like:</p>

<div><pre class="line-numbers"><code class="language-php">class UserServiceTest extends TestCase
{
    /**
     * Creates a user with correct permissions
     */
    public function setUp()
    {
        $this-&gt;user = factory(User::class);
        $this-&gt;user-&gt;addresses()-&gt;save(new Address);
        $this-&gt;user-&gt;givePermissions(&#39;add news&#39;, &#39;edit news&#39;, &#39;delete news&#39;, &#39;list news&#39;);
    }
    
    public function testOne()
    {
        $this-&gt;user;
    }
    
    public function testTwo()
    {
        $this-&gt;user;
    }
}</code></pre></div>

<p>Now before each test is run, you can have your user prepared for you without writing it a <em>thousand</em> times!</p>

<p>At the same time, we have a <code>tearDown</code> method, which you may have guessed.... runs after each test has run!</p>

<div><pre class="line-numbers"><code class="language-php">    /**
     * Creates a user with correct permissions
     */
    public function setUp()
    {
        $this-&gt;user = factory(User::class);
        $this-&gt;user-&gt;givePermissions(&#39;upload photos&#39;);
    }

    public function test_i_can_upload_photos()
    {
        $this
            -&gt;actingAs($this-&gt;user)
            -&gt;post(&#39;upload-photo&#39;, [
                &#39;photo&#39; =&gt; FakeFile::class
            ]);
    }

    /**
     * Cleans up all the uploaded files so they don&#39;t use up your disk space!
     */
    public function tearDown()
    {
        Storage::deleteDirectory(&#39;./uploads/photos&#39;);
    }</code></pre></div>

<h3 id="toc_8">Authenticating Users</h3>

<p>Another thing you might need to do when preparing your tests is to be authenticated. Most actions require the user to be logged in.</p>

<p>This is pretty easy in Laravel, typically we do it via 1 of 2 ways. </p>

<h4 id="toc_9"> Laravel Passport</h4>

<p>If the application is API driven, then we use Passports facade to log us in for all API calls e.g.</p>

<div><pre class="line-numbers"><code class="language-php">Passport::actingAs(
    factory(User::create)-&gt;create()
);</code></pre></div>

<p>Now ever API call we make it will authenticate you as that user.</p>

<h4 id="toc_10">Session/Auth Driver</h4>

<p>If you&#39;re just using a normal authentication flow by a form for example, then each call we make to our application we define the user we&#39;re doing it on the behalf of e.g.</p>

<div><pre class="line-numbers"><code class="language-php">$this
    -&gt;actingAs($this-&gt;user)
    -&gt;post(&#39;upload-photo&#39;, [
        &#39;photo&#39; =&gt; FakeFile::class
    ]);</code></pre></div>

<h2 id="toc_11">Testing Concepts</h2>

<p>In Laravel try to keep terminology simple, having on 3 categories of tests</p>

<ul>
<li>Feature tests</li>
<li>Browser tests</li>
<li>Unit tests</li>
</ul>

<p>You could think of it as..</p>

<ul>
<li>If you&#39;re using Dusk or Selenium it&#39;s a Browser test</li>
<li>If you&#39;re testing a single function e.g <code>MathService::addTogether(1, 3)</code> it&#39;s a unit test.</li>
<li>If it&#39;s anything else, then it&#39;s a Feature test.</li>
</ul>

<p>That means all things like integration testing, end-to-end testing etc - they&#39;re all considered as feature tests.</p>

<h3 id="toc_12">Feature Tests</h3>

<p>Typically Feature tests will not test a single thing - they will enter through a chain of other functions and is the only way to test Private/Protected methods.</p>

<p>An example could be.</p>

<div><pre class="line-numbers"><code class="language-php">public function test_an_authenticated_user_can_upload_a_photo()
{
    $this
    -&gt;actingAs($this-&gt;user)
    -&gt;post(&#39;upload-photo&#39;, [
        &#39;photo&#39; =&gt; FakeFile::class
    ]);}
</code></pre></div>

<p>This would end up hitting the following chain of calls.</p>

<div><pre class="line-numbers"><code class="language-php">class PhotoUploadController
{
    public function __invoke($request)
    {
        $response = UploadService::saveFromRequest($request);
        
        return $response;
    }
}

class UploadService
{
    public function saveFromRequest($request)
    {
        if (!UserService::canUpload($request-&gt;user)) {
            throw new Exception(&#39;User does not have permission to upload photos&#39;);
        }
        
        // Continue...
    }
}

class UserService
{
    public function canUpload($user)
    {
        return $this-&gt;can($user, &#39;upload photos&#39;);
    }
    
    private function can($user, $permission)
    {
        return DB::permissions($user-&gt;id, $permission)-&gt;count();
    }    
}</code></pre></div>

<p>As you can see here, the <code>PhotoUploadController</code> receives the uploaded file, it then passes it off to the <code>UploadService</code> which checks the user has permission via the <code>UserService</code> which internally calls a private method <code>can()</code>.</p>

<p>This chain of calling would be considered as a Feature test as it has the ability to test the whole feature, rather than just the isolated method.</p>

<p>Because the <code>can()</code> function is private, it can only be invoked by the <code>UserService</code> which means you cannot write a Unit test for it. What you can do however is create a test which inherantly tests it is doing what it is expected via the above process, or create a test which is more isolated, perhaps a unit test for <code>UserService::canUpload()</code> which will in turn call the <code>can()</code> method proving if it works or not.</p>

<h3 id="toc_13">Unit Tests</h3>

<p>As mentioned previously, Unit tests can be used for testing things in much more isolation - traditionally they will be used to test a single thing. However we&#39;re not getting into definitions - this is more about keeping a simple to follow structure rather than symantics.</p>

<p>So we don&#39;t mind if you&#39;re unit tests actually do a couple of things, e.g. something like</p>

<div><pre class="line-numbers"><code class="language-php">public function test_i_can_post_new_ideas()
{
    $user = factory(User::class);
    
    $idea = $user-&gt;createIdea([
        &#39;idea&#39; =&gt; &#39;We should all go to Hawaii&#39;
    ]);
    
    $this-&gt;assertNotNull($idea);
    $this-&gt;assertEquals(1, Idea::count());
}
</code></pre></div>

<p>Will end up doing something like</p>

<div><pre class="line-numbers"><code class="language-php">class User 
{
    public function createIdea($data)
    {
        if (!$user-&gt;can(&#39;create ideas&#39;)) {
            throw new Exception(&#39;This user does not have permission to create ideas.&#39;);
        }

        $idea = new Idea($data);
        $this-&gt;ideas()-&gt;save($idea);

        if ($base64 = data_get($data, &#39;photo&#39;, null)) {
            $idea-&gt;attachPhoto($base64);
        }

        if ($categories = data_get($data, &#39;categories&#39;)) {
            $idea-&gt;categories()-&gt;associate(...$categories);
        }

        event(
            new IdeaCreated($idea)
        );

        IdeaService::rebuildStatisticCache();

        return $idea;
    }
}</code></pre></div>

<p>You can see this method is actually doing 7 things</p>

<ul>
<li>Running its own validation</li>
<li>Creating the idea entity</li>
<li>Attaching a photo</li>
<li>Associating categories</li>
<li>Firing an event</li>
<li>Rebuilding the cache</li>
<li>Returning the new idea entity</li>
</ul>

<p>So although this method does actually cross over into the realm of potentially being a Feature test - we believe its quite acceptable to organise this within your Unit folders when you deem appropriate.</p>

<p>However remember - you can only run this sort of test on <code>public</code> methods, <code>protected</code> and <code>private</code> methods can only be tested by going via a public method - so these might be considered as feature tests.</p>

<h3 id="toc_14">Browser Tests</h3>

<p>Laravel comes with a built in API for using headless Google Chrome - meaning you can run browser tests via PHPUnit using Laravel Dusk.</p>

<p>It is built upon the Facebook Webdriver and only works with Chrome currently - however you can configure it to use any other Selenium Server like Browserstack.</p>

<p>It lets you test more general purpose things like if a contact or registration form works as expected.</p>

<div><pre class="line-numbers"><code class="language-php">
$this-&gt;browse(function ($browser) use ($user) {
    
    $browser-&gt;maximize();

    $browser-&gt;loginAs($user)
            -&gt;visit(&#39;/contact&#39;)
            -&gt;waitFor(&#39;.form.loaded&#39;, 5)
            -&gt;type(&#39;email&#39;, $user-&gt;email)
            -&gt;type(&#39;message&#39;, &#39;this is my message&#39;)
            -&gt;press(&#39;Send&#39;)
            -&gt;waitFor(&#39;.form.success&#39;)
            -&gt;assertPathIs(&#39;/thank-you&#39;)
            -&gt;assertSee(&#39;Thank you for your message&#39;);
});</code></pre></div>

<h3 id="toc_15">Test Driven Development</h3>

<p>This is a massive concept which can be covered in much better detail by <a href="https://course.testdrivenlaravel.com/">https://course.testdrivenlaravel.com/</a></p>

<p>However in a nut-shell it is the concept of instead of using your browser or something like postman to keep hitting an endpoint or a page, you write the code you WANT to interact with, a term coined as <q>Programming by wishful thinking</q> - Effectively it is write the code you WISH you could use, even if it doesn&#39;t exist yet.</p>

<blockquote>
<p>Cavet - Only really works well for bespoke functionality that doesn&#39;t have to integrate too deeply into other systems without having to worry about things like Mocking etc.</p>
</blockquote>

<p>This is a very fast, solid way to develop (assuming you&#39;re not tasked with building a GUI) as it:</p>

<ul>
<li>Removes the need to use a browser,</li>
<li>You fulfill user story requirements as you go,</li>
<li>A side-affect is self documenting your application code,</li>
<li>Allows you to refactor / clean up code once you know it works,</li>
<li>Leaves you with a suite of tests for the future!</li>
</ul>

<p>The general concept runs along the line of:</p>

<ul>
<li>Write the test</li>
<li>Run the test</li>
<li>Fix the failure</li>
<li>Run the test</li>
<li>Fix the failure</li>
<li>etc etc etc</li>
<li>Feature finished</li>
</ul>

<h2 id="toc_16">Writing Tests</h2>

<p>A general rule of thumb is to try and make your tests only test your application code, don&#39;t worry about testing framework or cms code - it will only waste time, and you can&#39;t fix it anyway. An example might be within Laravel, do not create tests for all your relationships - as you&#39;re just testing the relationship system in laravel works - you&#39;re other tests should inherantly prove they are working anyway.</p>

<h3 id="toc_17">Test Names</h3>

<p>These don&#39;t need to follow PSR naming, often people find using underscores make them easier to read, e.g <code>test_a_user_can_create_a_post</code> to some might read better than <code>TestAUserCanCreateAPost</code>.</p>

<p>You should try and be clear and concise about your test name, use full sentences to be as descriptive as possible, even if its long! If your tests are passing, then it won&#39;t be regually read anyway!</p>

<h3 id="toc_18">Test Structure</h3>

<p>A good way to organise your test code is to use a pattern known as AAA, this stands for</p>

<ul>
<li>Arrange</li>
<li>Act</li>
<li>Assert</li>
</ul>

<h3 id="toc_19">Arrange</h3>

<p>So the arrange concept effecitvely suggests that you organise everything you need to do to get the test ready, this could look something like. Anything which you need to be sure of, you should always hard-code. e.g If you know you need the user to be <code>id = 1</code> then pass it in.</p>

<div><pre class="line-numbers"><code class="language-php">function test_a_user_can_create_a_new_post()
{
    // Arrange
    $user = factory(User::class)-&gt;create([
        &#39;id&#39; =&gt; 1,
    ]);
    
    $user-&gt;givePermission(&#39;create posts&#39;);
}</code></pre></div>

<h3 id="toc_20">Act / Action</h3>

<p>This is where you&#39;re likely to start actually integrating with your application and where the most complex logic could likely happen, this is where you will make API calls, run methods, actions etc</p>

<div><pre class="line-numbers"><code class="language-php">function test_a_user_can_create_a_new_post()
{
    // Arrange
    $user = factory(User::class)-&gt;create([
        &#39;id&#39; =&gt; 1,
    ]);
    
    $user-&gt;givePermission(&#39;create posts&#39;);
    
    // Act
    $post = $user-&gt;createPost([
        &#39;title&#39; =&gt; &#39;amazing idea&#39;,
        &#39;body&#39; =&gt; &#39;We should totes solve world hunger.&#39;,
    ]);
}</code></pre></div>

<h3 id="toc_21">Assert</h3>

<p>Technically the assertion phase is where things are proved to be right/wrong - however it might be that if an exception is thrown in your <code>createPost</code> it will also cause the test to fail.</p>

<p>You will need to carefuly decide what you&#39;re actually testing for - and make sure the assertion tries to keep to this, often is it tempting to throw in as many assertions as possible, but this will just slow down your application and can lead people to start chasing geese in a test when the actual error is elsewhere.</p>

<p>There are a variety of assertions which can be used, Laravel provides many custom assertions for certain things, however you can always rely on the core PHPUnit assertions, or create your own!</p>

<p>You can see a selection of assertions <a href="https://laravel.com/docs/5.6/http-tests#response-assertions">https://laravel.com/docs/5.6/http-tests#response-assertions</a> but they are mentioned in a variety of places throughout the website.</p>

<p>Its worth remembering that the hardcoded value should always be the 1st param you pass into an assertion, this is because some methods require this format, so they keep it consistent.</p>

<p>e.g If you&#39;re testing 2 things match you should do something like:</p>

<div><pre class="line-numbers"><code class="language-php">$this-&gt;assertEquals(5, $idea-&gt;count); // Good
$this-&gt;assertEquals($idea-&gt;count, 5); // Bad</code></pre></div>

<p>A basic assertion for the above test could be something like.</p>

<div><pre class="line-numbers"><code class="language-php">function test_a_user_can_create_a_new_post()
{
    // Arrange
    $user = factory(User::class)-&gt;create([
        &#39;id&#39; =&gt; 1,
    ]);
    
    $user-&gt;givePermission(&#39;create posts&#39;);
    
    // Act
    $post = $user-&gt;createPost([
        &#39;title&#39; =&gt; &#39;amazing idea&#39;,
        &#39;body&#39; =&gt; &#39;We should totes solve world hunger.&#39;,
    ]);
    
    // Assert
    
    // If we expect the method to return a Post, we need to check it is.
    $this-&gt;assertInstanceOf(Post::class, $post);
    
    // We should test that the post was actually saved to the database
    $this-&gt;assertTrue($post-&gt;exists);
    
    // And test it was created on behalf of our test user.
    $this-&gt;assertEquals(1, $post-&gt;user_id);
}</code></pre></div>



<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
</script>

<script type="text/javascript">
Prism.languages.php=Prism.languages.extend("clike",{keyword:/\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,constant:/\b[A-Z0-9_]{2,}\b/,comment:{pattern:/(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/,lookbehind:!0}}),Prism.languages.insertBefore("php","class-name",{"shell-comment":{pattern:/(^|[^\\])#.*/,lookbehind:!0,alias:"comment"}}),Prism.languages.insertBefore("php","keyword",{delimiter:/\?>|<\?(?:php)?/i,variable:/\$\w+\b/i,"package":{pattern:/(\\|namespace\s+|use\s+)[\w\\]+/,lookbehind:!0,inside:{punctuation:/\\/}}}),Prism.languages.insertBefore("php","operator",{property:{pattern:/(->)[\w]+/,lookbehind:!0}}),Prism.languages.markup&&(Prism.hooks.add("before-highlight",function(e){"php"===e.language&&(e.tokenStack=[],e.backupCode=e.code,e.code=e.code.replace(/(?:<\?php|<\?)[\w\W]*?(?:\?>)/gi,function(a){return e.tokenStack.push(a),"{{{PHP"+e.tokenStack.length+"}}}"}))}),Prism.hooks.add("before-insert",function(e){"php"===e.language&&(e.code=e.backupCode,delete e.backupCode)}),Prism.hooks.add("after-highlight",function(e){if("php"===e.language){for(var a,n=0;a=e.tokenStack[n];n++)e.highlightedCode=e.highlightedCode.replace("{{{PHP"+(n+1)+"}}}",Prism.highlight(a,e.grammar,"php").replace(/\$/g,"$$$$"));e.element.innerHTML=e.highlightedCode}}),Prism.hooks.add("wrap",function(e){"php"===e.language&&"markup"===e.type&&(e.content=e.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g,'<span class="token php">$1</span>'))}),Prism.languages.insertBefore("php","comment",{markup:{pattern:/<[^?]\/?(.*?)>/,inside:Prism.languages.markup},php:/\{\{\{PHP[0-9]+\}\}\}/}));
</script>

<script type="text/javascript">
Prism.languages.insertBefore("php","variable",{"this":/\$this\b/,global:/\$(?:_(?:SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE)|GLOBALS|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/,scope:{pattern:/\b[\w\\]+::/,inside:{keyword:/(static|self|parent)/,punctuation:/(::|\\)/}}});
</script>

<script type="text/javascript">
Prism.languages.markup={comment:/<!--[\w\W]*?-->/,prolog:/<\?[\w\W]+?\?>/,doctype:/<!DOCTYPE[\w\W]+?>/,cdata:/<!\[CDATA\[[\w\W]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=.$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,inside:{punctuation:/[=>"']/}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
</script>

<script type="text/javascript">
!function(){"undefined"!=typeof self&&self.Prism&&self.document&&Prism.hooks.add("complete",function(e){if(e.code){var t=e.element.parentNode,s=/\s*\bline-numbers\b\s*/;if(t&&/pre/i.test(t.nodeName)&&(s.test(t.className)||s.test(e.element.className))&&!e.element.querySelector(".line-numbers-rows")){s.test(e.element.className)&&(e.element.className=e.element.className.replace(s,"")),s.test(t.className)||(t.className+=" line-numbers");var n,a=e.code.match(/\n(?!$)/g),l=a?a.length+1:1,m=new Array(l+1);m=m.join("<span></span>"),n=document.createElement("span"),n.className="line-numbers-rows",n.innerHTML=m,t.hasAttribute("data-start")&&(t.style.counterReset="linenumber "+(parseInt(t.getAttribute("data-start"),10)-1)),e.element.appendChild(n)}}})}();
</script>


</body>

</html>
